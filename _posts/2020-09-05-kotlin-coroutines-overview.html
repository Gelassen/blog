---
layout: post
title: 'Kotlin coroutines overview'
date: '2020-09-05'
author: Gelassen
tags: 
modified_time: '2020-09-05'
---
<html>
    <head>
        <link rel="stylesheet" href=".css/general.css">
    </head>
    
    <body>
        <div class="header" style="text-align: left;">
        </div>
        <div>
            <p>
                Last week I have to refresh my knowledge about kotlin coroutines and this publication is it's overview.
            </p>
            <h3 style="text-align: left;">Where it comes from</h3>
            <p>
                Originally appeared in 1960x in COBOL&Simula. Threads were introduced a bit later and market preferred them. 
                They have been using quite a long time until one its issue become more and more disturbing. <br /><br />
    
                Threads are quite expensive mechanism (in resources terms), there is a limit how much threads can be run at the same time. 
                When demand in scalability is growing this limit becomes an issue. <br /><br />
                
                Market introduced async/await mechanism as an attempt to solve this issue. Coroutines were next attempt. 
            </p>
            <h3 style="text-align: left;">Why do we need it</h3>
            <p>
                When you run a thread to do some work in the background sometimes you need to get back result of this work. Common practice is to pass ref on Callback 
                and call it from the thread. This approach leads to rising amount of callbacks calls which is known as 'callbacks hell'. <br /><br />
    
                Future/Promises/Deffered were a response on this issue, but they brought a new one -- writing async code becomes a new paradigm and you have to combine it 
                with paradigm of writing non async code. <br /><br />
                
                Coroutines were introduced as a solution for that. It allows you to do block of code in parallel, it is lightweight and allows you write async and non async code in the same style. <br /><br />
            </p>
            <h3 style="text-align: left;">How does it work</h3>
            <p>
                Kotlin extends a signature of a method by passing Continuation function as a parameter and adding 'suspend' modifier to the method. 
                <br /><br />
                
                <pre>
    
                    inline fun <T> Continuation(
                        context: CoroutineContext,
                        crossinline resumeWith: (Result<T>) -> Unit
                    ): Continuation<T>
                </pre>
                <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation.html">'Continuation' in the official documentation</a> <br/><br/>
    
                Continuation function wraps call on next suspend function. The call of this continuation object is optional and might be not called at all. <br /><br />
    
                Then compiler transforms all suspend functions into state machine and through continuation object traverse over it. Function behind continuation object 
                might be called in same or new thread which brings additional flexibility. Here is continuation object passing into all methods is the same which is 
                valuable optimisation compare with others solutions, e.g. Promises. <br />
    
                <a href="https://image.slidesharecdn.com/2017geekout-introductiontokotlincoroutines-170609161713/95/introduction-to-kotlin-coroutines-18-638.jpg?cb=1502800140">Kotlin code transformed into state machine.</a> <br /><br />
            </p>
            <h3 style="text-align: left;">How does it integrate existing codebase</h3>
            <p>
                It does over integration library and extension <code>await()</code>. await() transforms Future (e.g. Call<T> from retrofit) to state machine 
                exploiting Future callbacks <br /><br />
                    
                suspendCoroutine() is that what stops a method and wraps block of executing code <br/> <br/>
        
                    <pre>
        
                        suspend inline fun <T> suspendCoroutine(
                            crossinline block: (Continuation<T>) -> Unit
                        ): T
                    </pre>
        
                <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/suspend-coroutine.html">suspendCoroutine() in the official documentation</a> <br/><br/>
        
                Traditional and suspend functions have different nature, it implies they would not be chained without some mediator. Coroutine builder act as 
                this mediator (e.g. launch {} block). In the nutshell it is a suspend wrapper around all block of code and, sometimes, mechanism that run parallelism. <br /><br />
        
                Execution context (CoroutineContext) defines thread to run in, e.g. launch(UI) {} runs the last method in block in the UI thread <br />
        
                <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">Coroutine context in the official documentation</a> <br /><br />
            </p>
            <h3 style="text-align: left;">Worth to note</h3>
            <p>
                Access&manipulation on shared resource can be done new and reinvented kotlin mechanisms: thread confinement, mutex and actors 
            
                <br /> <br />
    
                <pre>
    
                    val counterContext = newSingleThreadContext("CounterContext")
                    var counter = 0
    
                    fun main() = runBlocking {
                        // confine everything to a single-threaded context
                        withContext(counterContext) {
                            massiveRun {
                                counter++
                            }
                        }
                        println("Counter = $counter")
                    }
                </pre>
    
                <a href="https://kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html#thread-confinement-fine-grained">More informatiion in official docs</a>
    
                Do not run function without access to the scope. If you need to launch a coroutine that keeps running after your function returns, 
                then make your function an extension of CoroutineScope or pass scope: CoroutineScope as parameter to make your intent clear in 
                your function signature. Do not make these functions suspending: [3] 
    
                <br /> <br />
    
                <pre>   
    
                    fun CoroutineScope.doThis() {
                        launch { println("I'm fine") }
                    }
                    
                    fun doThatIn(scope: CoroutineScope) {
                        scope.launch { println("I'm fine, too") }
                    }
                </pre>
            </p>

        </div> 
        <p>
            Materials used: <br/>
            [1] <a href="https://www.youtube.com/watch?v=3xalVUY69Ok">Roman Elizarov's intro into coroutines</a> <br />
            [2] <a href="https://www.cs.tufts.edu/~nr/cs257/archive/roberto-ierusalimschy/revisiting-coroutines.pdf">Origins of coroutines</a> <br />
            [3] <a href="https://medium.com/@elizarov/coroutine-context-and-scope-c8b255d59055">Proper use of coroutine scope</a> <br />
        </p>
    </body>
</html>
